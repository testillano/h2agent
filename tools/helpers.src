#!/bin/echo "source me!"

#############
# VARIABLES #
#############
PNAME=${PNAME:-h2agent}
TRAFFIC_URL=${TRAFFIC_URL:-"http://localhost:8000"}
METRICS_URL=${METRICS_URL:-"http://localhost:8080/metrics"}
ADMIN_URL=${ADMIN_URL:-"http://localhost:8074/admin/v1"}
[ "${SERVER_API}" = "/" ] && SERVER_API=
CURL="curl -i --http2-prior-knowledge"
BEAUTIFY_JSON=yes

#############
# FUNCTIONS #
#############
do_curl() {
  echo
  echo [${CURL} $@]
  echo
  ${CURL} $@ 2>/dev/null | tee /tmp/curl.out
  [ $? -ne 0 ] && return 1

  [ -n "${PLAIN}" ] && return 0 # special for trace()

  # Last empty line or no line feed (no body answered):
  [ -z $(tail -c 1 /tmp/curl.out) ] && return 0

  [ -n "${BEAUTIFY_JSON}" ] && echo -e "\n\nPRETTY BODY PRINTOUT (disable on curl operation unsetting 'BEAUTIFY_JSON'):" && pretty
  echo -e "\n\n(type 'pretty' or 'raw' to isolate body printout)\n"
}

schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: schema [-h|--help] [--clean] [file]; Cleans/gets/updates current schema configuration (${ADMIN_URL}/schema)." && return 0
  [ -z "$1" ] && do_curl ${ADMIN_URL}/schema && return 0
  if [ "$1" = "--clean" ]
  then
    do_curl -XDELETE ${ADMIN_URL}/schema
  else
    do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/schema
  fi
}

schema_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: schema_schema [-h|--help]; Gets the schema configuration schema (${ADMIN_URL}/schema/schema)." && return 0
  do_curl "${ADMIN_URL}/schema/schema"
}

global_variable() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: global_variable [-h|--help] [--clean] [name|file]; Cleans/gets/updates current agent global variable configuration (${ADMIN_URL}/global-variable)." && return 0
  [ -z "$1" ] && do_curl ${ADMIN_URL}/global-variable && return 0
  local queryParam=
  if [ "$1" = "--clean" ]
  then
    [ -n "$2" ] && queryParam="?name=$2"
    do_curl -XDELETE ${ADMIN_URL}/global-variable${queryParam}
  else
    [ -n "$1" ] && queryParam="?name=$1"
    if [ -f "$1" ]
    then
      do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/global-variable
    else
      do_curl ${ADMIN_URL}/global-variable${queryParam}
    fi
  fi
}

global_variable_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: global_variable_schema [-h|--help]; Gets the agent global variable configuration schema (${ADMIN_URL}/global-variable/schema)." && return 0
  do_curl "${ADMIN_URL}/global-variable/schema"
}

files() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: files [-h|--help]; Gets the files processed."
    return 0
  else
    do_curl ${ADMIN_URL}/files
  fi
}

files_configuration() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: files_configuration [-h|--help]; Manages files configuration (gets current status by default)."
    echo "                            [--enable-read-cache]  ; Enables cache for read operations."
    echo "                            [--disable-read-cache] ; Disables cache for read operations."
    return 0
  elif [ "$1" = "--enable-read-cache" ]
  then
    do_curl -XPUT "${ADMIN_URL}/files/configuration?readCache=true"
  elif [ "$1" = "--disable-read-cache" ]
  then
    do_curl -XPUT "${ADMIN_URL}/files/configuration?readCache=false"
  else
    do_curl ${ADMIN_URL}/files/configuration
  fi
}

udp_sockets() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: udp_sockets [-h|--help]; Gets the udp sockets processed."
    return 0
  else
    do_curl ${ADMIN_URL}/udp-sockets
  fi
}

configuration() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: configuration [-h|--help]; Gets agent general static configuration."
    return 0
  else
    do_curl ${ADMIN_URL}/configuration
  fi
}

server_configuration() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: server_configuration [-h|--help]; Manages agent server configuration (gets current status by default)."
    echo "                            [--traffic-server-ignore-request-body]             ; Ignores request body on server receptions."
    echo "                            [--traffic-server-receive-request-body]            ; Processes request body on server receptions."
    echo "                            [--traffic-server-dynamic-request-body-allocation] ; Does dynamic request body memory allocation on server receptions."
    echo "                            [--traffic-server-initial-request-body-allocation] ; Pre reserves request body memory on server receptions."
    return 0
  elif [ "$1" = "--traffic-server-ignore-request-body" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server/configuration?receiveRequestBody=false"
  elif [ "$1" = "--traffic-server-receive-request-body" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server/configuration?receiveRequestBody=true"
  elif [ "$1" = "--traffic-server-dynamic-request-body-allocation" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server/configuration?preReserveRequestBody=false"
  elif [ "$1" = "--traffic-server-initial-request-body-allocation" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server/configuration?preReserveRequestBody=true"
  else
    do_curl ${ADMIN_URL}/server/configuration
  fi
}

server_data_configuration() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: server_data_configuration [-h|--help]; Manages agent server data configuration (gets current status by default)."
    echo "                                 [--discard-all]     ; Discards all the events processed."
    echo "                                 [--discard-history] ; Keeps only the last event processed for a key."
    echo "                                 [--keep-all]        ; Keeps all the events processed."
    echo "                                 [--disable-purge]   ; Skips events post-removal when a provision on 'purge' state is reached."
    echo "                                 [--enable-purge]    ; Processes events post-removal when a provision on 'purge' state is reached."
    return 0
  elif [ "$1" = "--discard-all" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server-data/configuration?discard=true&discardKeyHistory=true"
  elif [ "$1" = "--discard-history" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server-data/configuration?discard=false&discardKeyHistory=true"
  elif [ "$1" = "--keep-all" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server-data/configuration?discard=false&discardKeyHistory=false"
  elif [ "$1" = "--disable-purge" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server-data/configuration?disablePurge=true"
  elif [ "$1" = "--enable-purge" ]
  then
    do_curl -XPUT "${ADMIN_URL}/server-data/configuration?disablePurge=false"
  else
    do_curl ${ADMIN_URL}/server-data/configuration
  fi
}

client_data_configuration() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: client_data_configuration [-h|--help]; Manages agent client data configuration (gets current status by default)."
    echo "                                 [--discard-all]     ; Discards all the events processed."
    echo "                                 [--discard-history] ; Keeps only the last event processed for a key."
    echo "                                 [--keep-all]        ; Keeps all the events processed."
    echo "                                 [--disable-purge]   ; Skips events post-removal when a provision on 'purge' state is reached."
    echo "                                 [--enable-purge]    ; Processes events post-removal when a provision on 'purge' state is reached."
    return 0
  elif [ "$1" = "--discard-all" ]
  then
    do_curl -XPUT "${ADMIN_URL}/client-data/configuration?discard=true&discardKeyHistory=true"
  elif [ "$1" = "--discard-history" ]
  then
    do_curl -XPUT "${ADMIN_URL}/client-data/configuration?discard=false&discardKeyHistory=true"
  elif [ "$1" = "--keep-all" ]
  then
    do_curl -XPUT "${ADMIN_URL}/client-data/configuration?discard=false&discardKeyHistory=false"
  elif [ "$1" = "--disable-purge" ]
  then
    do_curl -XPUT "${ADMIN_URL}/client-data/configuration?disablePurge=true"
  elif [ "$1" = "--enable-purge" ]
  then
    do_curl -XPUT "${ADMIN_URL}/client-data/configuration?disablePurge=false"
  else
    do_curl ${ADMIN_URL}/client-data/configuration
  fi
}

server_matching() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_matching [-h|--help] [file]; Gets/updates current server matching configuration (${ADMIN_URL}/server-matching)." && return 0
  [ -z "$1" ] && do_curl ${ADMIN_URL}/server-matching && return 0
  do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/server-matching
}

server_matching_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_matching_schema [-h|--help]; Gets the server matching configuration schema (${ADMIN_URL}/server-matching/schema)." && return 0
  do_curl "${ADMIN_URL}/server-matching/schema"
}

server_provision() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_provision [-h|--help] [--clean] [file]; Cleans/gets/updates current server provision configuration (${ADMIN_URL}/server-provision)." && return 0
  [ -z "$1" ] && do_curl ${ADMIN_URL}/server-provision && return 0
  if [ "$1" = "--clean" ]
  then
    do_curl -XDELETE ${ADMIN_URL}/server-provision
  else
    do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/server-provision
  fi
}

server_provision_unused() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_provision_unused [-h|--help]; Get current server provision configuration still not used (${ADMIN_URL}/server-provision/unused)." && return 0
  do_curl ${ADMIN_URL}/server-provision/unused && return 0
}

server_provision_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_provision_schema [-h|--help]; Gets the server provision configuration schema (${ADMIN_URL}/server-provision/schema)." && return 0
  do_curl "${ADMIN_URL}/server-provision/schema"
}

server_data() {
  local curl_method=
  local surf=

  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: server_data [-h|--help]; Inspects server data events (${ADMIN_URL}/server-data)."
    echo "                   [method] [uri] [[-]event number] [event path] ; Restricts shown data with given positional filters."
    echo "                                                                   Event number may be negative to access by reverse chronological order."
    echo "                   [--summary] [max keys]          ; Gets current server data summary to guide further queries."
    echo "                                                     Displayed keys (method/uri) could be limited (5 by default, -1: no limit)."
    echo "                   [--clean] [query filters]       ; Removes server data events. Admits additional query filters to narrow the selection."
    echo "                   [--surf]                        ; Interactive sorted (regardless method/uri) server data navigation."
    return 0
  elif [ "$1" = "--summary" ]
  then
    local maxKeys=${2:-5}
    local queryParams=
    [ -n "${maxKeys}" ] && queryParams="?maxKeys=${maxKeys}"
    [ "${maxKeys}" = "-1" ] && queryParams=
    do_curl "${ADMIN_URL}/server-data/summary${queryParams}"
    return 0
  elif [ "$1" = "--clean" ]
  then
    curl_method="-XDELETE"
    shift
  elif [ "$1" = "--surf" ]
  then
    surf=yes
    shift
  fi

  local requestMethod=$1
  local requestUri=$2
  local eventNumber=$3
  local eventPath=$4

  local keyIndicators=""
  [ -n "${requestMethod}" ] && keyIndicators+="x"
  [ -n "${requestUri}" ] && keyIndicators+="x"
  [ "${keyIndicators}" = "x" -a -z "${surf}" ] && echo "Error: both method & uri must be provided" && return 1
  [ -n "${eventNumber}" -a -z "${keyIndicators}" ] && echo "Error: method/uri are also required when eventNumber is provided" && return 1
  [ -n "${eventPath}" -a -z "${eventNumber}" ] && echo "Error: eventNumber is required when eventPath is provided" && return 1

  local queryParams=
  [ -n "${requestMethod}" ] && queryParams="?requestMethod=${requestMethod}" # request URI not added here (it must be encoded with --data-urlencode)
  [ -n "${eventNumber}" ] && queryParams="${queryParams}&eventNumber=${eventNumber}"
  if [ -z "${curl_method}" -a -z "${queryParams}" ]
  then
    if [ -n "${surf}" ]
    then
      do_curl ${ADMIN_URL}/server-data >/dev/null
      pretty | jq 'map(. as $parent | .events |= sort_by(.serverSequence) | .events[] | {events: [.], method: $parent.method, uri: $parent.uri}) | sort_by(.events[].serverSequence)' > /tmp/curl.out.sorted
      local indx_max=$(jq '.[].events[].serverSequence' /tmp/curl.out.sorted | wc -l)
      local indx=0
      [ ! -s /tmp/curl.out.sorted ] && echo && cat /tmp/curl.out && return 0
      while true
      do
        echo -e "\nMessage $((indx+1)):\n"
        jq ".[$indx]" /tmp/curl.out.sorted
        indx=$((indx+1))
        [ $indx -eq $indx_max ] && echo -e "\n\nThat's all ! ($indx_max events)\n" && return 0
        echo -e "\n\nPress ENTER to print next sequence ..."
        read -r dummy
      done
    else
      echo
      echo "Take care about storage size when querying without filters."
      echo "You may want to check the summary before: server_data --summary"
      echo
      echo "Press ENTER to continue, CTRL-C to abort ..."
      read -r dummy
      do_curl ${ADMIN_URL}/server-data
    fi
  else
    local urlencode=
    [ -n "${requestUri}" ] && urlencode="--data-urlencode requestUri=${requestUri}"
    [ -n "${eventPath}" ] && urlencode+=" --data-urlencode eventPath=${eventPath}"
    if [ -n "${requestUri}" ]
    then
      do_curl ${curl_method} -G ${urlencode} "${ADMIN_URL}/server-data${queryParams}"
    else
      do_curl ${curl_method} "${ADMIN_URL}/server-data"
    fi
  fi
}

client_data() {
  local curl_method=
  local surf=

  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: client_data [-h|--help]; Inspects client data events (${ADMIN_URL}/client-data)."
    echo "                   [client endpoint id] [method] [uri] [[-]event number] [event path] ; Restricts shown data with given positional filters."
    echo "                                                                                        Event number may be negative to access by reverse chronological order."
    echo "                   [--summary] [max keys]          ; Gets current client data summary to guide further queries."
    echo "                                                     Displayed keys (client endpoint id/method/uri) could be limited (5 by default, -1: no limit)."
    echo "                   [--clean] [query filters]       ; Removes client data events. Admits additional query filters to narrow the selection."
    echo "                   [--surf]                        ; Interactive sorted (regardless endpoint/method/uri) client data navigation."
    return 0
  elif [ "$1" = "--summary" ]
  then
    local maxKeys=${2:-5}
    local queryParams=
    [ -n "${maxKeys}" ] && queryParams="?maxKeys=${maxKeys}"
    [ "${maxKeys}" = "-1" ] && queryParams=
    do_curl "${ADMIN_URL}/client-data/summary${queryParams}"
    return 0
  elif [ "$1" = "--clean" ]
  then
    curl_method="-XDELETE"
    shift
  elif [ "$1" = "--surf" ]
  then
    surf=yes
    shift
  fi

  local clientEndpointId=$1
  local requestMethod=$2
  local requestUri=$3
  local eventNumber=$4
  local eventPath=$5

  local keyIndicators=""
  [ -n "${clientEndpointId}" ] && keyIndicators+="x"
  [ -n "${requestMethod}" ] && keyIndicators+="x"
  [ -n "${requestUri}" ] && keyIndicators+="x"
  [ "${keyIndicators}" != "" -a "${keyIndicators}" != "xxx" -a -z "${surf}" ] && echo "Error: client endpoint id & method & uri must be provided" && return 1
  [ -n "${eventNumber}" -a -z "${keyIndicators}" ] && echo "Error: client endpoint id/method/uri are also required when eventNumber is provided" && return 1
  [ -n "${eventPath}" -a -z "${eventNumber}" ] && echo "Error: eventNumber is required when eventPath is provided" && return 1

  local queryParams=
  [ -n "${clientEndpointId}" ] && queryParams="?clientEndpointId=${clientEndpointId}"
  [ -n "${requestMethod}" ] && queryParams="${queryParams}&requestMethod=${requestMethod}" # request URI not added here (it must be encoded with --data-urlencode)
  [ -n "${eventNumber}" ] && queryParams="${queryParams}&eventNumber=${eventNumber}"
  if [ -z "${curl_method}" -a -z "${queryParams}" ]
  then
    if [ -n "${surf}" ]
    then
      do_curl ${ADMIN_URL}/client-data >/dev/null
      pretty | jq 'map(. as $parent | .events |= sort_by(.clientSequence) | .events[] | {events: [.], method: $parent.method, uri: $parent.uri}) | sort_by(.events[].clientSequence)' > /tmp/curl.out.sorted
      local indx_max=$(jq '.[].events[].clientSequence' /tmp/curl.out.sorted | wc -l)
      local indx=0
      [ ! -s /tmp/curl.out.sorted ] && echo && cat /tmp/curl.out && return 0
      while true
      do
        echo -e "\nMessage $((indx+1)):\n"
        jq ".[$indx]" /tmp/curl.out.sorted
        indx=$((indx+1))
        [ $indx -eq $indx_max ] && echo -e "\n\nThat's all ! ($indx_max events)\n" && return 0
        echo -e "\n\nPress ENTER to print next sequence ..."
        read -r dummy
      done
    else
      echo
      echo "Take care about storage size when querying without filters."
      echo "You may want to check the summary before: client_data --summary"
      echo
      echo "Press ENTER to continue, CTRL-C to abort ..."
      read -r dummy
      do_curl ${ADMIN_URL}/client-data
    fi
  else
    local urlencode=
    [ -n "${requestUri}" ] && urlencode="--data-urlencode requestUri=${requestUri}"
    [ -n "${eventPath}" ] && urlencode+=" --data-urlencode eventPath=${eventPath}"
    if [ -n "${requestUri}" ]
    then
      do_curl ${curl_method} -G ${urlencode} "${ADMIN_URL}/client-data${queryParams}"
    else
      do_curl ${curl_method} "${ADMIN_URL}/client-data"
    fi
  fi
}

server_data_sequence() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_data_sequence [-h|--help] [value (available values by default)]; Extract server sequence document from json retrieved in previous server_data() call." && return 0
  [ -z "$1" ] && pretty ".[].events[].serverSequence" | sort -n && return 0
  pretty ".[] | select (.events[].serverSequence == $1) | del (.events[] | select (.serverSequence != $1))" 2>/dev/null
}

client_data_sequence() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_data_sequence [-h|--help] [value (available values by default)]; Extract client sequence document from json retrieved in previous client_data() call." && return 0
  [ -z "$1" ] && pretty ".[].events[].clientSequence" | sort -n && return 0
  pretty ".[] | select (.events[].clientSequence == $1) | del (.events[] | select (.clientSequence != $1))" 2>/dev/null
}

client_endpoint() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_endpoint [-h|--help] [--clean] [file]; Cleans/gets/updates current client endpoint configuration (${ADMIN_URL}/client-endpoint)." && return 0
  [ -z "$1" ] && do_curl ${ADMIN_URL}/client-endpoint && return 0
  if [ "$1" = "--clean" ]
  then
    do_curl -XDELETE ${ADMIN_URL}/client-endpoint
  else
    do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/client-endpoint
  fi
}

client_endpoint_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_endpoint_schema [-h|--help]; Gets the client endpoint configuration schema (${ADMIN_URL}/client-endpoint/schema)." && return 0
  do_curl "${ADMIN_URL}/client-endpoint/schema"
}

client_provision() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: client_provision [-h|--help] [--clean]; Cleans/gets/updates/triggers current client provision configuration (${ADMIN_URL}/client-provision)."
    echo "                                       [file]; Configure client provision by mean json specification."
    echo "                        [id] [id query param]; Triggers client provision identifier and optionally provide dynamics configuration (omit with empty value):"
    echo "                                               [inState, sequenceBegin, sequenceEnd, rps, repeat (true|false)]"
    return 0
  fi

  [ -z "$1" ] && do_curl ${ADMIN_URL}/client-provision && return 0
  if [ "$1" = "--clean" ]
  then
    do_curl -XDELETE ${ADMIN_URL}/client-provision
  else
    if [ -f "$1" ]
    then
      do_curl -XPOST -d@${1} -H 'content-type:application/json' ${ADMIN_URL}/client-provision
    else
      local queryParams=
      [ -n "$2" ] && queryParams+="&inState=$2"
      [ -n "$3" ] && queryParams+="&sequenceBegin=$3"
      [ -n "$4" ] && queryParams+="&sequenceEnd=$4"
      [ -n "$5" ] && queryParams+="&rps=$5"
      [ -n "$6" ] && queryParams+="&repeat=$6"
      [ -n "${queryParams}" ] && queryParams=$(echo ${queryParams} | sed 's/&/?/')
      do_curl -XGET "${ADMIN_URL}/client-provision/${1}${queryParams}"
    fi
  fi
}

client_provision_unused() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_provision_unused [-h|--help]; Get current client provision configuration still not used (${ADMIN_URL}/client-provision/unused)." && return 0
  do_curl ${ADMIN_URL}/client-provision/unused && return 0
}

client_provision_schema() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_provision_schema [-h|--help]; Gets the client provision configuration schema (${ADMIN_URL}/client-provision/schema)." && return 0
  do_curl "${ADMIN_URL}/client-provision/schema"
}

launch_client_provision() {
  [ "$1" = "-h" -o "$1" = "--help" -o -z "$1" ] && echo "Usage: launch_client_provision [-h|--help] <id>; Activates client provision given its identifier (${ADMIN_URL}/client-provision/<id>)." && return 0
  do_curl -XPUT ${ADMIN_URL}/client-provision/$1
}

pretty() {
  local jq_expr=${1:-.}
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: pretty [-h|--help]; Beautifies json content for last operation response."
    echo "              [jq expression, '.' by default]; jq filter over previous content."
    echo "              Example filter: schema && pretty '.[] | select(.id==\"myRequestsSchema\")'"
    return 0
  fi
  tail -n -1 /tmp/curl.out | jq "${jq_expr}"
}

raw() {
  local jq_expr=${1:-.}
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: raw [-h|--help]; Outputs raw json content for last operation response."
    echo "           [jq expression, '.' by default]; jq filter over previous content."
    echo "           Example filter: schema && raw '.[] | select(.id==\"myRequestsSchema\")'"
    return 0
  fi
  tail -n -1 /tmp/curl.out | jq -c "${jq_expr}"
}

trace() {
  local level=$1
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: trace [-h|--help] [level: Debug|Informational|Notice|Warning|Error|Critical|Alert|Emergency]; Gets/sets h2agent tracing level."
    return 0
  fi
  if [ -n "$1" ]
  then
    echo -n "Level selected: ${level}"
    local recommended_level="Warning"
    [ "$1" != "${recommended_level}" ] && echo -n " (recommended '${recommended_level}' for normal operation)."
    echo
    PLAIN=true do_curl -XPUT ${ADMIN_URL}/logging?level=${level}
  else
    PLAIN=true do_curl -XGET ${ADMIN_URL}/logging
  fi
}

metrics() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: metrics [-h|--help]; Prometheus metrics." && return 0
  curl ${METRICS_URL}
}

snapshot() {
  if [ "$1" = "-h" -o "$1" = "--help" ]
  then
    echo "Usage: snapshot [-h|--help]; Creates a snapshot directory with process data & configuration."
    echo "                [target dir]; Directory where information is stored ('/tmp/snapshots/last' by default)."
    return 0
  fi

  local dir=${1:-"/tmp/snapshots/$(date +'%y%m%d.%H%M%S')"}
  mkdir -p ${dir} || return 1

  if [ -n "$1" ]
  then
    [ -n "$(ls -A ${dir})" ] && echo "Target directory '${dir}' is not empty !" && return 1
  else
    local last=/tmp/snapshots/last
    rm -f ${last} && ln -s $(basename ${dir}) ${last}
  fi

  schema && pretty > ${dir}/schema.json
  schema_schema && pretty > ${dir}/schema_schema.json
  global_variable && pretty > ${dir}/global-variable.json
  global_variable_schema && pretty > ${dir}/global-variable_schema.json
  files && pretty > ${dir}/files.json
  files_configuration && pretty > ${dir}/files-configuration.json
  udp_sockets && pretty > ${dir}/udp-sockets.json
  configuration && pretty > ${dir}/configuration.json

  server_configuration && pretty > ${dir}/server-configuration.json
  server_data_configuration && pretty > ${dir}/server-data-configuration.json
  client_data_configuration && pretty > ${dir}/client-data-configuration.json
  server_matching && pretty > ${dir}/server-matching.json
  server_matching_schema && pretty > ${dir}/server-matching_schema.json
  server_provision && pretty > ${dir}/server-provision.json
  server_provision_unused && pretty > ${dir}/server-provision_unused.json
  server_provision_schema && pretty > ${dir}/server-provision_schema.json
  server_data --summary -1 && pretty > ${dir}/server-data-summary.json
  echo | server_data && pretty > ${dir}/server-data.json
  mkdir ${dir}/server-data-sequences
  (jq '.[].events[].serverSequence' ${dir}/server-data.json | sort -nu | tr '\n' ' ' && echo) > ${dir}/server-data-sequences.txt
  for s in $(cat ${dir}/server-data-sequences.txt); do
    jq ".[] | select (.events[].serverSequence == $s) | del (.events[] | select (.serverSequence != $s))" ${dir}/server-data.json > ${dir}/server-data-sequences/${s}.json
  done
  client_data --summary -1 && pretty > ${dir}/client-data-summary.json
  echo | client_data && pretty > ${dir}/client-data.json
  mkdir ${dir}/client-data-sequences
  (jq '.[].events[].clientSequence' ${dir}/client-data.json | sort -nu | tr '\n' ' ' && echo) > ${dir}/client-data-sequences.txt
  for s in $(cat ${dir}/client-data-sequences.txt); do
    jq ".[] | select (.events[].clientSequence == $s) | del (.events[] | select (.clientSequence != $s))" ${dir}/client-data.json > ${dir}/client-data-sequences/${s}.json
  done
  client_endpoint && pretty > ${dir}/client_endpoint.json
  client_endpoint_schema && pretty > ${dir}/client_endpoint_schema.json
  client_provision && pretty > ${dir}/client-provision.json
  client_provision_unused && pretty > ${dir}/client-provision_unused.json
  client_provision_schema && pretty > ${dir}/client-provision_schema.json
  client_data --summary -1 && pretty > ${dir}/client-data-summary.json
  echo | client_data && pretty > ${dir}/client-data.json
  mkdir ${dir}/client-data-sequences
  (jq '.[].events[].clientSequence' ${dir}/client-data.json | sort -nu | tr '\n' ' ' && echo) > ${dir}/client-data-sequences.txt
  for s in $(cat ${dir}/client-data-sequences.txt); do
    jq ".[] | select (.events[].clientSequence == $s) | del (.events[] | select (.clientSequence != $s))" ${dir}/client-data.json > ${dir}/client-data-sequences/${s}.json
  done
  metrics > ${dir}/metrics.txt

  echo
  echo "Created snapshot at:"
  if [ -n "$1" ]
  then
    readlink -f ${dir}
  else
    ls -l ${last}
  fi
}

server_example() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: server_example [-h|--help]; Basic server configuration examples. Try: source <(server_example)" && return 0

  # If h2agent is up, we will suggest as example the same server matching configuration detected, to avoid breaking its behaviour
  #  (provisions and schemas are probably not harmful because of their dummy names):
  local foo_server_matching=$(curl --http2-prior-knowledge ${ADMIN_URL}/server-matching 2>/dev/null | jq '.' -c)
  [ -z "${foo_server_matching}" ] && foo_server_matching="{\"algorithm\":\"FullMatching\"}" # fallback to basic example

  local server_api_path=
  [ -n "${SERVER_API}" ] && server_api_path="/${SERVER_API}"

  cat << EOF

  # Configure 'dummySchemaId' to be referenced later:
  cat << ! > /tmp/dummySchema.json
  {
    "\\\$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "additionalProperties": true,
    "properties": {
      "foo": { "type": "number" }
    },
    "required": [ "foo" ]
  }
!
  jq --arg id "dummySchemaId" '. | { id: \$id, schema: . }' /tmp/dummySchema.json > /tmp/h2agent_dummySchema.json
  schema /tmp/h2agent_dummySchema.json # configuration

  ###############
  # SERVER MOCK #
  ###############

  # Configure classification algorithm:
  echo '${foo_server_matching}' > /tmp/dummyServerMatching.json
  server_matching /tmp/dummyServerMatching.json # configuration

  # Configure basic server provision to answer the same request received:
  cat << ! > /tmp/dummyServerProvision.json
  {
    "requestMethod": "POST",
    "requestUri": "${server_api_path}/my/dummy/path",
    "requestSchemaId": "dummySchemaId",
    "responseSchemaId": "dummySchemaId",
    "responseDelayMs": 0,
    "responseCode": 201,
    "responseHeaders": {
      "content-type": "application/json"
    },
    "transform": [
      { "source": "request.body", "target": "response.body.json.object" }
    ]
  }
!
  server_provision /tmp/dummyServerProvision.json # configuration

  # Check configuration
  schema && server_matching && server_provision

  # Test it !
  \${CURL} -d'{"foo":1, "bar":2}' \${TRAFFIC_URL}${server_api_path}/my/dummy/path

EOF
}

client_example() {
  [ "$1" = "-h" -o "$1" = "--help" ] && echo "Usage: client_example [-h|--help]; Basic client configuration examples. Try: source <(client_example)" && return 0

  # Implementation pending
  echo TODO
}

help() {
  echo
  echo "===== ${PNAME} operation helpers ====="
  echo "Shortcut helpers (sourced variables and functions)"
  echo "to ease agent operation over management interface:"
  echo "   https://github.com/testillano/h2agent#management-interface"
  echo
  echo "=== Variables ==="
  echo "TRAFFIC_URL=${TRAFFIC_URL}"
  [ -n "${SERVER_API}" ] && echo "SERVER_API=${SERVER_API}"
  echo "ADMIN_URL=${ADMIN_URL}"
  echo "CURL=\"${CURL}\""
  echo
  echo "=== General ==="
  schema -h
  global_variable -h
  files -h
  files_configuration -h
  udp_sockets -h
  configuration -h
  echo
  echo "=== Traffic server ==="
  server_configuration -h
  server_data_configuration -h
  server_matching -h
  server_provision -h
  server_provision_unused -h
  server_data -h
  server_data_sequence -h
  echo
  echo "=== Traffic client ==="
  client_endpoint -h
  client_provision -h
  client_provision_unused -h
  client_data -h
  client_data_sequence -h
  echo
  echo "=== Schemas ==="
  schema_schema -h
  global_variable_schema -h
  server_matching_schema -h
  server_provision_schema -h
  client_endpoint_schema -h
  client_provision_schema -h
  echo
  echo "=== Auxiliary ==="
  pretty -h
  raw -h
  trace -h
  metrics -h
  snapshot -h
  server_example -h
  client_example -h
  echo "Usage: help; This help. Overview: help | grep ^Usage"
  echo
}

#############
# EXECUTION #
#############

# Check dependencies:
if ! type curl &>/dev/null; then echo "Missing required dependency (curl) !" ; return 1 ; fi
if ! type jq &>/dev/null; then echo "Missing required dependency (jq) !" ; return 1 ; fi

# Initialize temporary and show help
touch /tmp/curl.out
help
