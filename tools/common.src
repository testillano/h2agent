#!/bin/echo "source me!"

# Requirements:
if ! type curl &>/dev/null; then echo "ERROR: tool 'curl' (with http2 support) must be installed (sudo apt install curl) !" ; return 1 ; fi
if ! type jq &>/dev/null; then echo "ERROR: tool 'jq' must be installed (sudo apt install jq) !" ; return 1 ; fi

# Color variables:
COLOR_reset='\e[0m'
COLOR_red='\e[31m'
COLOR_l_red='\e[91m'
COLOR_green='\e[32m'
COLOR_l_green='\e[92m'
COLOR_yellow='\e[33m'
COLOR_l_yellow='\e[93m'
COLOR_blue='\e[34m'
COLOR_l_blue='\e[94m'
COLOR_magenta='\e[35m'
COLOR_l_magenta='\e[95m'
COLOR_cyan='\e[36m'
COLOR_l_cyan='\e[96m'

# $1: title literal; $2: color code (red by default); $3: pattern character (= by default)
title()
{
  local literal=$1
  local color=${2:-${COLOR_red}}
  local pattern=${3:-=}

  local title="${pattern} ${literal} ${pattern}"
  local line=$(eval printf "%0.s${pattern}" {1..${#title}})
  echo -e "${color}${line}\n${title}\n${line}${COLOR_reset}"
}

# $1: title; $2: method; $3: url
# Prepend variables
#   (*) EXPECTED_STATUS_CODES: space-separated list of expected http status code(s)
#   (*) EXPECTED_BODY: expected reponse body
#   (*) CURL_OPTS: additional curl options
#   (*) ASSERT_IGNORED_FIELDS: ignored nodes at body validation
#       INTERACT: non-empty value to go step by step
#       VERBOSE: non-empty value to set verbose output
#       TMPDIR: temporary directory (must be defined externally)
#
# (*) reset applied at the end
test_query() {
  local info=$1
  local method=$2
  local url=$3

  [ -z "${TMPDIR}" ] && echo "Temporary directory 'TMPDIR' must be defined !" && return 1

  local rc=0
  echo
  title "${info}" "" "-"
  local cmd="curl -i -X${method} --http2-prior-knowledge ${CURL_OPTS} ${url}"
  if [ -n "${VERBOSE}" ]
  then
    echo "Command to be executed:"
    echo "   ${cmd}"
    echo
    [ -n "${EXPECTED_STATUS_CODES}" ] && echo "Expected HTTP status code(s): ${EXPECTED_STATUS_CODES}"
    if [ -n "${EXPECTED_BODY}" ]
    then
      echo "Expected response body:"
      echo ${EXPECTED_BODY} | jq '.'
    fi
    echo "--------------------------------------------------------------------------"
  fi
  if [ -n "${INTERACT}" ]
  then
    echo -n "Press ENTER to execute ..."
    read -r dummy
  fi
  echo

  eval ${cmd} > ${TMPDIR}/cmd.out 2>${TMPDIR}/cmd.err
  cat ${TMPDIR}/cmd.out
  echo
  echo "--------------------------------------------------------------------------"

  local receivedStatusCode=$(grep "^HTTP/2" ${TMPDIR}/cmd.out | awk '{ print $2 }')
  local receivedBody=$(grep ^{ ${TMPDIR}/cmd.out)

  if [ -n "${EXPECTED_STATUS_CODES}" ]
  then
    if [ -z "${receivedStatusCode}" ]
    then
      echo "Status code not received !"
      cat ${TMPDIR}/cmd.err 2>/dev/null
      return 1
    fi
    echo "${EXPECTED_STATUS_CODES}" | grep -qw ${receivedStatusCode}
    [ $? -ne 0 ] && rc=1 && echo "Expected status code(s) differs from received: ${receivedStatusCode}"
  fi

  local jq_expr="."
  if [ -n "${EXPECTED_BODY}" ]
  then
    # Normalize with jq and ignore 'time' node, and optionally, 'phone' (it is random for unassigned):
    [ -n "${ASSERT_IGNORED_FIELDS}" ] && jq_expr="del(${ASSERT_IGNORED_FIELDS})"
    expected=$(echo ${EXPECTED_BODY} | jq "${jq_expr}")
    received=$(echo ${receivedBody} | jq "${jq_expr}")
    [ "${expected}" != "${received}" ] && rc=1 && echo -e "Expected body differs from received:\nExpected:\n${expected}\nReceived:\n${received}"
  fi

  if [ ${rc} -eq 0 ]
  then
    echo -n "Response is OK :-)"
    [ -n "${ASSERT_IGNORED_FIELDS}" ] && echo -n " (ignored fields: ${jq_expr})"
    echo
  else
    echo "Response is NOK :_("
    cat ${TMPDIR}/cmd.err 2>/dev/null
  fi
  if [ -n "${INTERACT}" ]
  then
    echo "Press ENTER to continue ..."
    read -r dummy
  fi

  # Reset
  EXPECTED_STATUS_CODES=
  EXPECTED_BODY=
  CURL_OPTS=
  ASSERT_IGNORED_FIELDS=

  # Return rc
  return ${rc}
}

