#!/bin/echo "source me!"

# Requirements:
if ! type curl &>/dev/null; then echo "ERROR: tool 'curl' (with http2 support) must be installed (sudo apt install curl) !" ; return 1 ; fi
if ! type jq &>/dev/null; then echo "ERROR: tool 'jq' must be installed (sudo apt install jq) !" ; return 1 ; fi

# $1: title; $2: method; $3: url
# Prepend variables
#   (*) EXPECTED_STATUS_CODES: space-separated list of expected http status code(s)
#   (*) EXPECTED_BODY: expected reponse body
#   (*) CURL_OPTS: additional curl options
#   (*) ASSERT_IGNORED_FIELDS: ignored nodes at body validation
#       INTERACT: non-empty value to go step by step
#       VERBOSE: non-empty value to set verbose output
#       TMPDIR: temporary directory (must be defined externally)
#
# (*) reset applied at the end
test_query() {
  local info=$1
  local method=$2
  local url=$3

  [ -z "${TMPDIR}" ] && echo "Temporary directory 'TMPDIR' must be defined !" && return 1

  local rc=0
  echo
  echo
  echo "=========================================================================="
  echo -e "${info}"
  echo "=========================================================================="
  local cmd="curl -i -X${method} --http2-prior-knowledge ${CURL_OPTS} ${url}"
  if [ -n "${VERBOSE}" ]
  then
    echo "Command to be executed:"
    echo "   ${cmd}"
    echo
    [ -n "${EXPECTED_STATUS_CODES}" ] && echo "Expected HTTP status code(s): ${EXPECTED_STATUS_CODES}"
    if [ -n "${EXPECTED_BODY}" ]
    then
      echo "Expected response body:"
      echo ${EXPECTED_BODY} | jq '.'
    fi
    echo "--------------------------------------------------------------------------"
  fi
  if [ -n "${INTERACT}" ]
  then
    echo -n "Press ENTER to execute ..."
    read -r dummy
  fi
  echo

  eval ${cmd} > ${TMPDIR}/cmd.out 2>/dev/null
  cat ${TMPDIR}/cmd.out
  echo
  echo "--------------------------------------------------------------------------"

  local receivedStatusCode=$(grep "^HTTP/2" ${TMPDIR}/cmd.out | awk '{ print $2 }')
  local receivedBody=$(grep ^{ ${TMPDIR}/cmd.out)

  if [ -n "${EXPECTED_STATUS_CODES}" ]
  then
    [ -z "${receivedStatusCode}" ] && echo "Status code not received !" && return 1
    echo "${EXPECTED_STATUS_CODES}" | grep -qw ${receivedStatusCode}
    [ $? -ne 0 ] && rc=1 && echo "Expected status code(s) differs from received: ${receivedStatusCode}"
  fi

  local jq_expr="."
  if [ -n "${EXPECTED_BODY}" ]
  then
    # Normalize with jq and ignore 'time' node, and optionally, 'phone' (it is random for unassigned):
    [ -n "${ASSERT_IGNORED_FIELDS}" ] && jq_expr="del(${ASSERT_IGNORED_FIELDS})"
    [ "$(echo ${EXPECTED_BODY} | jq '"${jq_expr}"')" != "$(echo ${receivedBody} | jq '"${jq_expr}"')" ] && rc=1 && echo "Expected body differs from received: ${receivedBody}"
  fi

  if [ ${rc} -eq 0 ]
  then
    echo -n "Response is OK :-)"
    [ -n "${ASSERT_IGNORED_FIELDS}" ] && echo -n " (ignored fields: ${jq_expr})"
    echo
  else
    echo "Response is NOK :_("
  fi
  if [ -n "${INTERACT}" ]
  then
    echo "Press ENTER to continue ..."
    read -r dummy
  fi

  # Reset
  EXPECTED_STATUS_CODES=
  EXPECTED_BODY=
  CURL_OPTS=
  ASSERT_IGNORED_FIELDS=

  # Return rc
  return ${rc}
}

